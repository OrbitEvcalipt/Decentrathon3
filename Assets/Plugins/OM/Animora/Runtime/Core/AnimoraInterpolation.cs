using System;
using System.Collections.Generic;
using UnityEngine;

namespace OM.Animora.Runtime
{
    /// <summary>
    /// A simple struct designed to hold the pre-calculated starting ('Zero') and ending ('One')
    /// values for a single interpolation instance after the setup process.
    /// This data is typically generated by <see cref="AnimoraInterpolation{T}.Setup"/> for each target
    /// and stored in a list within the <see cref="AnimoraInterpolation{T}"/> class.
    /// </summary>
    /// <typeparam name="T">The struct type of the values being interpolated (e.g., float, Vector3, Color).</typeparam>
    // Making this a struct means it's passed by value, which is efficient for holding simple data pairs.
    public struct AnimoraInterpolationData<T> where T : struct // Constraint: T must be a value type (struct).
    {
        /// <summary>
        /// The calculated starting value for the interpolation.
        /// This value is determined during the `Setup` phase of <see cref="AnimoraInterpolation{T}"/>
        /// based on its interpolation type (e.g., fixed value, current target value) and randomization settings.
        /// </summary>
        public T Zero;

        /// <summary>
        /// The calculated ending value for the interpolation.
        /// This value is determined during the `Setup` phase of <see cref="AnimoraInterpolation{T}"/>
        /// based on its interpolation type (e.g., fixed value, current target value + offset) and randomization settings.
        /// </summary>
        public T One;

        // This struct purely holds the results of the setup phase for use during the Interpolate() calls.
    }
    
    /// <summary>
    /// An attribute used to mark fields (typically of type <see cref="AnimoraInterpolation{T}"/>)
    /// within other classes (like custom Animora Actions or Clips).
    /// It currently provides a flag (`UseOptional`) which might be used by custom editors or reflection logic
    /// to modify how the marked interpolation field is handled or displayed.
    /// </summary>
    // Specifies that this attribute can only be applied to class fields.
    [AttributeUsage(AttributeTargets.Field)]
    public class AnimoraInterpolationAttribute : Attribute // Inherit from System.Attribute to make it a custom attribute
    {
        /// <summary>
        /// Gets a value indicating whether the associated interpolation is considered optional.
        /// The interpretation of "optional" depends on the context where this attribute is checked
        /// (e.g., an editor might hide it by default if optional, or validation logic might ignore it).
        /// Defaults to true.
        /// </summary>
        public bool UseOptional { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AnimoraInterpolationAttribute"/> class.
        /// </summary>
        /// <param name="useOptional">Specifies whether the interpolation associated with the marked field
        /// should be considered optional. Defaults to true.</param>
        public AnimoraInterpolationAttribute(bool useOptional = true)
        {
            // Assign the provided value to the UseOptional property.
            UseOptional = useOptional;
        }
    }

    /// <summary>
    /// Defines the different ways an <see cref="AnimoraInterpolation{T}"/> can determine
    /// its starting value ('Zero') when the <see cref="AnimoraInterpolation{T}.Setup"/> method is called.
    /// </summary>
    public enum AnimoraInterpolationType
    {
        /// <summary>
        /// The interpolation starts from the explicitly defined 'Zero' value
        /// configured in the <see cref="AnimoraInterpolation{T}"/> instance
        /// (which might be fixed or randomized). Interpolates towards the 'One' value.
        /// </summary>
        FromZeroToOne,

        /// <summary>
        /// The interpolation starts from the target component's *current* value
        /// at the exact moment the <see cref="AnimoraInterpolation{T}.Setup"/> method is called.
        /// Interpolates towards the configured 'One' value. Useful for smooth transitions from the current state.
        /// </summary>
        FromCurrentToOne,

        /// <summary>
        /// The interpolation starts from the target component's *current* value
        /// at the exact moment the <see cref="AnimoraInterpolation{T}.Setup"/> method is called.
        /// The *end* value is calculated by adding the configured 'One' value to the starting current value.
        /// Useful for relative animations (e.g., move *by* 5 units, rotate *by* 90 degrees).
        /// Requires an addition function delegate to be provided during Setup.
        /// </summary>
        FromCurrentByOne,
    }
    
    /// <summary>
    /// A generic class designed to manage interpolation between two values (`zero` and `one`) of a struct type <typeparamref name="T"/>.
    /// It supports different interpolation modes (e.g., FromZeroToOne, FromCurrentToOne), easing functions,
    /// optional randomization of start/end values, and setup logic for single or multiple targets.
    /// </summary>
    /// <typeparam name="T">The struct type of the values being interpolated (e.g., float, Vector3, Color, Quaternion).</typeparam>
    [System.Serializable] // Allows this class to be serialized by Unity when used as a field in a MonoBehaviour or ScriptableObject.
    public class AnimoraInterpolation<T> where T : struct // Constraint: T must be a value type (struct).
    {
        /// <summary>
        /// Determines if this interpolation instance is active and should be processed.
        /// </summary>
        [SerializeField]
        [Tooltip("Enable/disable this interpolation.")]
        private bool enabled = true;

        /// <summary>
        /// Specifies how the interpolation should behave, determining the starting point ('Zero' value).
        /// </summary>
        [SerializeField]
        [Tooltip("Determines how the interpolation starts:\n" +
                 "FromZeroToOne: Starts from the defined 'Zero' value.\n" +
                 "FromCurrentToOne: Starts from the target's current value at the time of setup.\n" +
                 "FromCurrentByOne: Starts from the target's current value and adds the defined 'One' value to it.")]
        private AnimoraInterpolationType interpolationType = AnimoraInterpolationType.FromZeroToOne;

        /// <summary>
        /// Defines the easing curve or function to apply to the interpolation progress (t).
        /// </summary>
        [SerializeField]
        [Tooltip("Easing curve or function applied to the interpolation progress.")]
        private EaseData ease = EaseData.GetDefault(); // Initialize with a default ease (e.g., Linear or a default AnimationCurve).

        /// <summary>
        /// If true, the 'Zero' and 'One' <see cref="AnimoraValue{T}"/> instances will potentially generate
        /// a new random value (if they are configured for randomness) for each target component
        /// during the <see cref="Setup"/> process when multiple targets are involved.
        /// If false, one random value (if applicable) is generated and used for all targets.
        /// </summary>
        [SerializeField]
        [Tooltip("If true, randomize start/end values for each target individually during Setup (if Zero/One values are set to random).")]
        private bool randomizeForEach;

        /// <summary>
        /// The starting value container for the interpolation. Can be a fixed value or randomized.
        /// The actual starting value used might depend on the <see cref="interpolationType"/>.
        /// </summary>
        [SerializeField]
        [Tooltip("The starting value (or range if random). Actual start depends on Interpolation Type.")]
        private AnimoraValue<T> zero;

        /// <summary>
        /// The ending value container for the interpolation. Can be a fixed value or randomized.
        /// This is typically the target value the interpolation aims for (or adds, in 'FromCurrentByOne' mode).
        /// </summary>
        [SerializeField]
        [Tooltip("The ending value (or range if random).")]
        private AnimoraValue<T> one;

        /// <summary>
        /// Internal list storing the prepared interpolation data (start and end values) for each target.
        /// For single targets, this list will contain one element. For multiple targets, it holds data per target.
        /// </summary>
        private List<AnimoraInterpolationData<T>> _interpolationData;

        /// <summary>
        /// Gets or sets whether this interpolation is enabled.
        /// </summary>
        public bool Enabled { get => enabled; set => enabled = value; }

        /// <summary>
        /// Constructor to create an interpolation instance with a specific enabled state.
        /// Initializes internal values to defaults.
        /// </summary>
        /// <param name="enabled">Initial enabled state.</param>
        public AnimoraInterpolation(bool enabled)
        {
            this.enabled = enabled;
            // Initialize other fields to defaults if needed (though serialization handles most)
             this.ease = EaseData.GetDefault();
             this.zero = new AnimoraValue<T>(default(T)); // Default struct value
             this.one = new AnimoraValue<T>(default(T));
        }

        /// <summary>
        /// Constructor defining fixed start ('zero') and end ('one') values.
        /// Assumes randomization per target is desired if multiple targets are used later.
        /// </summary>
        /// <param name="zero">The fixed starting value.</param>
        /// <param name="one">The fixed ending value.</param>
        /// <param name="randomizeForEach">Whether to randomize per target if Zero/One are later configured for randomness (defaults to true, though less relevant for fixed values).</param>
        public AnimoraInterpolation(T zero, T one, bool randomizeForEach = true)
        {
            // Create AnimoraValue containers for the fixed values.
            this.zero = new AnimoraValue<T>(zero);
            this.one = new AnimoraValue<T>(one);
            this.randomizeForEach = randomizeForEach;
            this.enabled = true; // Default to enabled
            this.ease = EaseData.GetDefault(); // Default ease
        }

        /// <summary>
        /// Constructor defining randomized start ('zero') and end ('one') values using ranges.
        /// </summary>
        /// <param name="zero">The base starting value (used if not random, ignored if random).</param>
        /// <param name="one">The base ending value.</param>
        /// <param name="randomValue1">The first boundary for randomization (min).</param>
        /// <param name="randomValue2">The second boundary for randomization (max).</param>
        /// <param name="randomizeForEach">Whether to generate a random value per target during Setup.</param>
        public AnimoraInterpolation(T zero, T one, T randomValue1, T randomValue2, bool randomizeForEach = true)
        {
            // Create AnimoraValue containers configured for randomization.
            this.zero = new AnimoraValue<T>(zero, randomValue1, randomValue2);
            this.one = new AnimoraValue<T>(one, randomValue1, randomValue2);
            this.randomizeForEach = randomizeForEach;
            this.enabled = true; // Default to enabled
            this.ease = EaseData.GetDefault(); // Default ease
        }

        /// <summary>
        /// Default constructor. Initializes the interpolation as enabled with default values.
        /// Requires setting 'zero' and 'one' values later or via serialization.
        /// </summary>
        public AnimoraInterpolation()
        {
            enabled = true;
            this.ease = EaseData.GetDefault();
            this.zero = new AnimoraValue<T>(default(T));
            this.one = new AnimoraValue<T>(default(T));
        }

        /// <summary>
        /// Sets up the interpolation data for a single target.
        /// Calculates the actual start ('Zero') and end ('One') values based on the <see cref="interpolationType"/>,
        /// target's current value (if needed), and randomization settings. Stores the result in <see cref="_interpolationData"/>.
        /// </summary>
        /// <typeparam name="TTarget">The type of the target object (usually Component).</typeparam>
        /// <param name="target">The target object instance.</param>
        /// <param name="getValue">A function delegate that returns the current value of type <typeparamref name="T"/> from the target.</param>
        /// <param name="addFunc">A function delegate that adds two values of type <typeparamref name="T"/> (used for 'FromCurrentByOne' mode).</param>
        /// <param name="direction">The current playback direction.</param>
        public void Setup<TTarget>(TTarget target, Func<T> getValue, Func<T, T, T> addFunc, OM_PlayDirection direction)
        {
            // --- Commented out: Logic to potentially skip setup on backward playback for certain types ---
            // This logic seems problematic and might prevent correct behavior when looping backward.
            // If setup needs to be conditional, it should likely be handled by the caller or be more robust.
            /*if (direction == OM_PlayDirection.Backward &&
                interpolationType == AnimoraInterpolationType.FromCurrentToOne &&
                _setup)
            {
                Debug.Log("jdjd"); // Example debug log
                return; // Skip setup
            }

            if (direction == OM_PlayDirection.Backward &&
                interpolationType == AnimoraInterpolationType.FromCurrentByOne && _setup)
            {
                return; // Skip setup
            }*/
            // --- End Commented Out Logic ---

            // Initialize or clear the interpolation data list for the new setup.
            _interpolationData = new List<AnimoraInterpolationData<T>>();

            // Potentially randomize the base 'zero' and 'one' values *once* if randomizeForEach is false.
            // The Get...Value methods handle the actual randomization logic internally.
            // Note: Randomize() inside AnimoraValue sets a flag or generates the value immediately.
             if (!randomizeForEach) {
                 zero?.Randomize(); // Call Randomize on the AnimoraValue object itself
                 one?.Randomize();
             }


            // Determine the actual start (data.Zero) and end (data.One) values based on the interpolation type.
            T actualZero = default(T);
            T actualOne = default(T);

            // Get the potentially randomized 'one' value. If randomizeForEach is true,
            // GetOneValue(true) ensures a new random value is generated.
            // If randomizeForEach is false, GetOneValue(false) retrieves the value randomized earlier (or the fixed value).
            actualOne = GetOneValue(randomizeForEach);

            switch (interpolationType)
            {
                case AnimoraInterpolationType.FromZeroToOne:
                    // Use the defined 'zero' value (potentially randomized similarly to 'one').
                    actualZero = GetZeroValue(randomizeForEach);
                    break;
                case AnimoraInterpolationType.FromCurrentToOne:
                    // Use the target's current value as the starting point.
                    actualZero = getValue(); // Get current value from the target
                    // 'actualOne' is already determined above.
                    break;
                case AnimoraInterpolationType.FromCurrentByOne:
                    // Use the target's current value as the starting point.
                    actualZero = getValue();
                    // Calculate the end value by adding the defined 'one' value to the start value.
                    actualOne = addFunc(actualZero, actualOne); // Use the add function delegate
                    break;
            }

            // Store the calculated start and end values for this target.
            _interpolationData.Add(new AnimoraInterpolationData<T> { Zero = actualZero, One = actualOne });
        }


        /// <summary>
        /// Sets up the interpolation data for a collection of targets.
        /// Calculates the actual start ('Zero') and end ('One') values for *each target* based on the
        /// <see cref="interpolationType"/>, each target's current value (if needed via <paramref name="getValue"/> with index),
        /// and randomization settings. Stores the results in <see cref="_interpolationData"/>.
        /// </summary>
        /// <typeparam name="TTarget">The type of the target objects (usually Component).</typeparam>
        /// <param name="targets">The collection of target object instances.</param>
        /// <param name="getValue">A function delegate that returns the current value of type <typeparamref name="T"/> for a target at a specific index.</param>
        /// <param name="addFunc">A function delegate that adds two values of type <typeparamref name="T"/> (used for 'FromCurrentByOne' mode).</param>
        /// <param name="direction">The current playback direction.</param>
        public void Setup<TTarget>(IEnumerable<TTarget> targets, Func<int, T> getValue, Func<T, T, T> addFunc, OM_PlayDirection direction)
        {
            // --- Commented out: Similar conditional setup skipping logic as the single target version ---
            /*if (direction == OM_PlayDirection.Backward &&
                interpolationType == AnimoraInterpolationType.FromCurrentToOne &&
                _setup)
            {
                return; // Skip
            }
            if (direction == OM_PlayDirection.Backward &&
                interpolationType == AnimoraInterpolationType.FromCurrentByOne && _setup)
            {
                return; // Skip
            }*/
             // --- End Commented Out Logic ---

            // Initialize or clear the interpolation data list.
            _interpolationData = new List<AnimoraInterpolationData<T>>();

            // Initialize index for iterating through targets.
            var index = 0;

             // Perform initial randomization *once* if not doing it per target.
             if (!randomizeForEach) {
                 zero?.Randomize();
                 one?.Randomize();
             }

            // Iterate through each target in the provided collection.
            foreach (var target in targets) // Using target variable isn't strictly necessary here if only index is used by delegates
            {
                // Determine start (actualZero) and end (actualOne) for the *current* target.
                T actualZero = default(T);
                T actualOne = default(T);

                // Get the potentially randomized 'one' value for this target.
                // If randomizeForEach is true, force randomization (true). Otherwise use pre-randomized (false).
                 actualOne = GetOneValue(randomizeForEach);

                switch (interpolationType)
                {
                    case AnimoraInterpolationType.FromZeroToOne:
                        // Get the potentially randomized 'zero' value for this target.
                         actualZero = GetZeroValue(randomizeForEach);
                        break;
                    case AnimoraInterpolationType.FromCurrentToOne:
                        // Get the current value for the target at the specific index.
                        actualZero = getValue(index);
                        // 'actualOne' already determined.
                        break;
                    case AnimoraInterpolationType.FromCurrentByOne:
                        // Get the current value for the target at the specific index.
                        actualZero = getValue(index);
                        // Calculate end value by adding 'one' to the current value.
                        actualOne = addFunc(actualZero, actualOne);
                        break;
                }

                // Store the calculated start and end values for the current target (at 'index').
                _interpolationData.Add(new AnimoraInterpolationData<T> { Zero = actualZero, One = actualOne });

                // Increment index for the next target.
                index++;
            }
        }

        /// <summary>
        /// Gets the calculated starting ('Zero') value for the interpolation.
        /// If randomization is enabled in the underlying <see cref="AnimoraValue{T}"/>,
        /// this may return a randomized value based on the <paramref name="forceRandomize"/> flag and setup state.
        /// </summary>
        /// <param name="forceRandomize">If true, forces the underlying <see cref="AnimoraValue{T}"/> to potentially generate a new random value.</param>
        /// <returns>The starting value.</returns>
        public T GetZeroValue(bool forceRandomize = false)
        {
            // Delegate to the GetValue method of the 'zero' AnimoraValue instance.
            // Returns default(T) if 'zero' is null.
            return zero != null ? zero.GetValue(forceRandomize) : default(T);
        }

        /// <summary>
        /// Gets the calculated ending ('One') value for the interpolation.
        /// If randomization is enabled in the underlying <see cref="AnimoraValue{T}"/>,
        /// this may return a randomized value based on the <paramref name="forceRandomize"/> flag and setup state.
        /// </summary>
        /// <param name="forceRandomize">If true, forces the underlying <see cref="AnimoraValue{T}"/> to potentially generate a new random value.</param>
        /// <returns>The ending value.</returns>
        public T GetOneValue(bool forceRandomize = false)
        {
             // Delegate to the GetValue method of the 'one' AnimoraValue instance.
             // Returns default(T) if 'one' is null.
            return one != null ? one.GetValue(forceRandomize) : default(T);
        }

        /// <summary>
        /// Evaluates the easing function defined by <see cref="ease"/> at a given progress point.
        /// </summary>
        /// <param name="progress">The interpolation progress, typically ranging from 0.0 to 1.0.</param>
        /// <returns>The eased progress value.</returns>
        public float Evaluate(float progress)
        {
             // Delegate to the Evaluate method of the EaseData instance.
             // Returns linear progress (input progress) if 'ease' is null.
            return ease != null ? ease.Evaluate(progress) : progress;
        }

        /// <summary>
        /// Interpolates between the prepared start and end values for the *first* target using a provided interpolation function.
        /// Applies easing to the time parameter <paramref name="t"/> before passing it to the function.
        /// Assumes <see cref="Setup"/> has been called and <see cref="_interpolationData"/> is populated.
        /// </summary>
        /// <param name="t">The raw progress factor (typically 0.0 to 1.0).</param>
        /// <param name="func">The interpolation function (e.g., Lerp, Slerp) taking (startValue, endValue, easedTime) and returning the interpolated value.</param>
        /// <returns>The interpolated value.</returns>
        /// <exception cref="IndexOutOfRangeException">Thrown if Setup was not called or resulted in an empty data list.</exception>
        public T Interpolate(float t, Func<T, T, float, T> func)
        {
             // Ensure setup has run and data exists.
             if (_interpolationData == null || _interpolationData.Count == 0) {
                  // Or return default(T)? Throwing highlights incorrect usage.
                  throw new InvalidOperationException("AnimoraInterpolation.Setup() must be called before Interpolate().");
              }
            // Apply easing to the progress factor 't'.
            float easedTime = Evaluate(t);
            // Call the provided interpolation function with the prepared start/end values for the first target [0] and the eased time.
            return func(_interpolationData[0].Zero, _interpolationData[0].One, easedTime);
        }

        /// <summary>
        /// Interpolates between the prepared start and end values for the target at the specified <paramref name="index"/>
        /// using a provided interpolation function. Applies easing to the time parameter <paramref name="t"/>.
        /// Assumes <see cref="Setup"/> has been called for multiple targets.
        /// </summary>
        /// <param name="t">The raw progress factor (typically 0.0 to 1.0).</param>
        /// <param name="index">The index of the target whose interpolation data should be used.</param>
        /// <param name="func">The interpolation function (e.g., Lerp, Slerp) taking (startValue, endValue, easedTime) and returning the interpolated value.</param>
        /// <returns>The interpolated value for the specified target.</returns>
        /// <exception cref="IndexOutOfRangeException">Thrown if the index is invalid or Setup was not called/populated correctly.</exception>
        public T Interpolate(float t, int index, Func<T, T, float, T> func)
        {
             // Ensure setup has run and data exists for the given index.
            if (_interpolationData == null || index < 0 || index >= _interpolationData.Count) {
                 // Or return default(T)? Throwing highlights incorrect usage.
                 throw new InvalidOperationException($"AnimoraInterpolation.Setup() must be called before Interpolate() for index {index}, or index is out of range.");
             }
            // Apply easing to the progress factor 't'.
            float easedTime = Evaluate(t);
            // Call the provided interpolation function with the prepared start/end values for the specified target [index] and the eased time.
            return func(_interpolationData[index].Zero, _interpolationData[index].One, easedTime);
        }

        /// <summary>
        /// Interpolates between explicitly provided start and end values using the instance's easing function.
        /// This overload bypasses the internal setup data (<see cref="_interpolationData"/>) and uses the easing defined in this instance.
        /// </summary>
        /// <param name="t">The raw progress factor (typically 0.0 to 1.0).</param>
        /// <param name="start">The explicit starting value.</param>
        /// <param name="end">The explicit ending value.</param>
        /// <param name="func">The interpolation function (e.g., Lerp, Slerp) taking (startValue, endValue, easedTime) and returning the interpolated value.</param>
        /// <returns>The interpolated value.</returns>
        public T Interpolate(float t, T start, T end, Func<T, T, float, T> func)
        {
            // Apply this instance's easing to the progress factor 't'.
            float easedTime = Evaluate(t);
            // Call the provided interpolation function with the explicit start/end values and the eased time.
            return func(start, end, easedTime);
        }
    }
}